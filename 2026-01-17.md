# Weekly Report

## Time:

| Date      | Hours    | Note                                          |
| --------- | -------- | --------------------------------------------- |
| Jan 12    | 2.17     | Codex experiments. Codex source code reading. |
| Jan 13    | 1        | Codex experiments.  Codex Prompt reading.     |
| Jan 14    | 1        | Class.                                        |
| Jan 15    | 2.66     | Reverse engineering codex.                    |
| Jan 16    | 1.96     | Reverse Engineering Codex.  Codex Tests.      |
| **Total** | **8.79** |                                               |


## Findings/Learnings

This week I discovered the codex source code and spent most of my time learning how codex ticks.  One feature
I found the most interesting was an experimental feature called collab.  In this feature, an orchistrator manages
the project and spawns worker agents to do the grunt work.  The orchistrator holds the context for the project, and
the workers only get what they need to do the job their given.  I found this interesting because It allowed for the
orchistrator agent to do more with less context.  It didn't have to think about how do code, it just had to know that
one agent had verified that another agent's code worked and was well written.  The feature behind a Beta flag, and
we don't have documentation on how to use it, so my experiments with the feature were haphazard at best.

While digging through the Codex source code, I also learned about context compacting.  Context compacting is a feature
that is automatically triggered by codex when the context window reaches capacity, but it can also be triggered manually
by the user. In this feature, an agent is given the current working contex, and reduces to only the most important bit. It
was interesting to read the prompt for the compacting agent and see how it's instructed to package the context for a hand off
rather than for a continued converstation.  I wonder how we could change the prompt of the context compactor to create different
compaction effects.  For example, I wonder how the compactor would work differently if it was told it was a sleep processor, working
to clean, refine, and repare the working context, rather than just preparing it for a hand off.  It would also be intereting to
allow the current working agent to choose when it's context is compacting. Imagine an agent getting "tired" and deciding it needs
to sleep.

Going into next week, I want to test the utility of Multi Agent Systems (MAS).  The collab feature in codex has one orchistrator
who spins multiple workers to get work done in parallel, but what if the focus was more on context preservation? To test this,
I'll modify codex's collab feature to use a new orchistrator prompt, and see if I can change how it views it's relationship with
worker agents.
